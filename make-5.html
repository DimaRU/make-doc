<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
<META HTTP-EQUIV="LAST-MODIFIED" CONTENT="Tue Jan 22 15:04:57 2002 GMT">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="Public">
<META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 
<TITLE> Программа управления компиляцией GNU make 3.73 : Написание команд в правилах </TITLE>
<META NAME="DESCRIPTION" CONTENT="Next Previous Contents 5. Написание команд в правилах Команды правила состоят из командых строк командной оболочки, предназначенных для выполнения их">
<META NAME="RESOURCE-TYPE" CONTENT="Document">
<META NAME="DISTRIBUTION" CONTENT="global">
<META NAME="ROBOTS" CONTENT="ALL">
<META NAME="CHANGED" CONTENT="20020122;15045700">
<META NAME="CHANGEDBY" CONTENT="Valentyn Solomko">
 <LINK HREF="make-6.html" REL=next>
 <LINK HREF="make-4.html" REL=previous>
 <LINK HREF="make.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="make-6.html">Next</A>
<A HREF="make-4.html">Previous</A>
<A HREF="make.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5. Написание команд в правилах </A></H2>

<P>      Команды  правила  состоят  из  командых  строк  командной оболочки,   
предназначенных  для  выполнения  их  одной  за другой. Каждая командная   
строка  должна  начинаться с символа табуляции, за исключением того, что   
первая  командная  строка  может  быть  присоединена  к  строке  целей и   
зависимостей   через  точку  с  запятой.  Среди  командных  строк  могут   
появляться пробельные строки и строки, состоящие только из комментария -   
они  игнорируются. (Но будьте осторожны - кажущаяся пробельной, сторока,   
начинающаяся  с  символа  табуляции,  не является пробельной! Это пустая   
команда - смотрите раздел 5.8 [Пустые команды]).   
<P>
<P>      Пользователи  используют  в качестве программных оболочек различные   
программы,  но  команды из make-файла всегда интерпретируются программой   
'/bin/sh',  если  в make-файле не определена другая. Смотрите раздел 5.2   
[Выполнение команд].   
<P>
<P>      Используемая  командная оболочка определяет, могут ли быть написаны   
комментарии в командных строках, и какой синтаксис они используют. Когда   
командной оболочкой является '/bin/sh', символ '#' начинает комментарий,   
который  продолжается  до конца строки. Символ '#' не обязательно должен   
быть в начале строки. Текст строки перед символом '#' не является частью   
комментария.   
<P>
<H2><A NAME="ss5.1">5.1 Отображение команды </A>
</H2>

<P>      Обычно  make печатает каждую командную строку перед ее выполнением.   
Мы  называем  это  отображением, поскольку создается впечатление, что вы   
сами набираете команду.   
<P>
<P>      Когда строка начинается с '@', отображение этой строки подавляется.   
Символ  '@'  отбрасывается,  прежде  чем  команда  передается  командной   
оболочке.   Обычно   вам   следует  использовать  это  для  тех  команд,   
единственным  действием  которых  является  вывод  чего-либо  на  экран,   
например  для команды echo, применяемой в целях индикации прохождения по   
make-файлу:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         @echo   About to make distribution files   
</PRE>
</CODE></BLOCKQUOTE>
    
Когда  программе  make  передается  опция  '-n' или '--just-print',   
происходит  только  отображение,  без  выполнения.  Смотрите  раздел 9.7   
[Обзор  опций].  В  этом и только в этом случае печатаются даже команды,   
начинающиеся  с символа '@      '. Эта опция полезна для выяснения того, какие   
команды make рассматривает как необходимые, без реального их выполнения.   
<P>
<P>      Опции   программы   make  '-s'  или  '--silent'  предотвращают  все   
отображения,  как  будто  все  команды  начинаются  с  '@      '.  Появление в   
make-файле  правила  без  зависимостей для специальной цели .SILENT дает   
такой  же  эффект  (смотрите  раздел  4.7  [Специальные встроенные имена   
целей]). .SILENT представляет собой явно устаревшую возможность, так как   
использование символа '@      ' является более гибким.   
<P>
<H2><A NAME="ss5.2">5.2 Выполнение команд </A>
</H2>

<P>      Когда  настает  время  выполнять  команды  для обновления цели, они   
выполняются  путем  создания  новой  командной  подоболочки  для  каждой   
строки.  (На  практике,  make  может осуществлять сокращения, которые не   
будут влиять на результаты.)   
<P>
<P>      ЗАМЕЧАНИЕ: это означает, что команды командной оболочки, такие, как   
cd,  которая  устанавливает  для  каждого  процесса  местоположение  его   
данных,  не  будут воздействовать на следующие командные строки. Если вы   
хотите, чтобы команда cd воздействовала на следующую команду, разместите   
обе  на  одной  строке с точкой с запятой между ними. В этом случае make   
будет  рассматривать  их как одну команду и передаст их вместе командной   
оболочке, которая последовательно выполнит их. Например:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      foo : bar/lose   
              cd bar; gobble lose &gt; ../foo   
</PRE>
</CODE></BLOCKQUOTE>
    
Если  вам  хотелось  бы  разбить одну команду командной оболочки на   
несколько тексовых строк, вы должны использовать символ '\' в конце всех   
ее  подстрок,  кроме последней. Такая последовательность текстовых строк   
объединяется  в  одну посредством удаления последовательностей 'обратная   
косая  черта  -  перевод  строки' перед передачей ее командной оболочке.   
Таким образом, написанное ниже эквивалентно предыдущему примеру:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      foo : bar/lose   
              cd bar;  \   
              gobble lose &gt; ../foo   
</PRE>
</CODE></BLOCKQUOTE>
    
Программа, используемая в качестве командной оболочки, определяется   
при  помощи  переменной  SHELL.  По  умолчанию,  используется  программа   
'/bin/sh'.   
<P>
<P>      В  отличие  от  большинства переменных, переменная SHELL никогда не   
устанавливается  из  командной  среды.  Так дело обстоит из-за того, что   
переменная  окружения  SHELL  используется  для определения вашей личной   
настройки  программы  командной  оболочки для диалогового использования.   
Было  бы  очень  плохо,  если  бы такого рода личная настройка влияла на   
функционирование   make-файлов.   Смотрите  раздел  6.9  [Переменные  из   
командной среды].   
<P>
<P>
<H2><A NAME="ss5.3">5.3 Параллельное выполнение </A>
</H2>

<P>      GNU-версия  программы  make  умеет одновременно выполнять несколько   
команд.  Обычно  make  будет выполнять одновременно только одну команду,   
ожидая  ее  завершения,  прежде,  чем запускать следующую. Однако, опция   
'-j'  или  '--jobs'  дает  программе make указание выполнять параллельно   
несколько команд.   
<P>
<P>      Если   за   опцией  '-j'  следует  целое  число,  то  оно  является   
количесивом  команд,  выполняемых  одновременно  -  это число называется   
количеством   рабочих   гнезд.   Если  после  опции  '-j'  нету  ничего,   
напоминающего целое число, это означает, что на количество рабочих гнезд   
ограничений нет. По умолчанию количество рабочих гнезд равно одному, что   
означает  последовательное  выполнение  (одна  команда  в  каждый момент   
времени).   
<P>
<P>      Одним  из  неприятных следствий параллельного выполнения нескольких   
команд  является  то, что выходные данные от всех команд приходят тогда,   
когда команды посылают их, поэтому сообщения от разных команд могут быть   
перемешаны.   
<P>
<P>      Еще   одна   проблема  заключается  в  невозможности  приема  двумя   
процессами  входных  данных  из  одного  и  того  же  устройства - таким   
образом, для того, чтобы убедиться, что одновременно только одна команда   
пытается  принимать входные данные с терминала, make закроет стандартные   
входные  потоки  всех выполняемых команд, кроме одной. Это означает, что   
попытка  чтения  со сандартного входа обычно обернется фатальной ошибкой   
(сигнал  'Broken  pipe')  для большинства порожденных процессов, если их   
несколько.   
<P>
<P>      Невозможно  предсказать,  какая  команда  будет  иметь  действующий   
входной  поток  (который  будет  идти  с терминала или оттуда, откуда вы   
перенаправили   стандартный  вход  программы  make).  Первая  запущенная   
команда  получит  его первым, а первая команда, стартовавшая после того,   
как та финишировала, получит его следующей, и так далее.   
<P>
<P>      Мы  изменим  этот  аспект работы программы make, если найдем лучшую   
альтернативу.  Между  тем, вам ни в коем случае не следует полагаться на   
использование   какой-либо   командой   стандартного   входа,   если  вы   
используете   возможность   параллельного  выполнения;  если  же  вы  не   
пользуетесь  этой  возможностью,  стандартный вход нормально работает во   
всех командах.   
<P>
<P>      Если  выполнение  команды  не  удается  (она уничтожается с помощью   
сигнала  или  завершается  с  ненулевым  результатом), и ошибки для этой   
команды  не  игнорируются  (смотрите  раздел  5.4  [Ошибки в командах]),   
оставшиеся  командные  строки  для обновления той же самой цели не будут   
выполняться.   Если  выполнение  команды  не  удается,  и  при  этом  не   
установлена  опция  '-k'  или '--keep-going' (смотрите раздел 9.7 [Обзор   
опций]),  make  прерывает  выполнение.  Если  make  разрушается по любым   
причинам  (включая  сигнал)  в тот момент, когда выполняются порожденные   
процессы, он ожидает их окончания, прежде чем на самом деле выйти.   
<P>
<P>      Когда  система  сильно  загружена,  вы, вероятно захотите выполнять   
меньше  заданий,  чем  тогда,  когда  она  загружена  слабо.  Вы  можете   
использовать  опцию  '-l',  чтобы  задать  программе make ограничение на   
количество  одновременно выполняемых заданий на основе средней загрузки.   
За  опцией  '-l'  или  '--max-load'  следует  число  с плавающей точкой.   
Например, опция   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         -l 2.5   
</PRE>
</CODE></BLOCKQUOTE>
   
не  позволит программе make запустить более одного задания, если средняя   
загрузка  превышает  2.5.  Опция  '-l',  за  которой  не  следует число,   
отменяет  ограничение  на загрузку, если оно было установлено предыдущей   
опцией '-l'.   
<P>
<P>      Более  точно, когда make собирается запустить задание, и у него уже   
выполняется  одно  задание, он проверяет текущую среднюю загрузку - если   
она  не  меньше чем предел, определенный с помощью '-l', make ожидает до   
тех  пор,  пока  средняя загрузка не опустится ниже предела, или пока не   
завершится другое задание.   
<P>
<P>      По умолчанию предел загрузки не установлен.   
<P>
<H2><A NAME="ss5.4">5.4 Ошибки в командах </A>
</H2>

<P>      После  завершения каждой команды командной оболочки make смотрит ее   
возвращаемый  результат. Если программа успешно завершилась, выполняется   
следующая  командная  строка  в новой командной оболочке; при завершении   
последней командной строки завершается правило.   
<P>
<P>      Если  встретилась ошибка (возвращаемый результат - ненулевой), make   
прекращает выполнение текущего правила и, возможно, всех правил.   
<P>
<P>      Иногда   неудачное  выполнение  определенной  команды  не  является   
признаком  проблемы.  Например,  вы  можете  использовать команду mkdir,   
чтобы  убедиться, что каталог существует. Если каталог существует, mkdir   
сообщит  об ошибке, но, тем не менее, вы, вероятно, захотите, чтобы make   
продолжил работу.   
<P>
<P>      Чтобы игнорировать ошибки в командной строке, напишите символ '-' в   
начале  ее  текста  (после  начального  символа  табуляции). Этот символ   
отбрасывается,  прежде  чем  команда передается для исполнения командной   
оболочке.   
<P>
<P>      Например:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      clean:   
    
              -rm -f *.o   
</PRE>
</CODE></BLOCKQUOTE>
    
Это  приводит к тому, что после rm выполнение команд будет продолжаться,   
даже если попытка удаления файлов окажется неудачной.   
<P>
<P>      Когда  вы  запускаете  make  с  опцией  '-i' или '--ignore-errors',   
ошибки  игнорируются во всех командах всех правил. Правило make-файла со   
специальной  целью  .IGNORE  имеет  такой  же  эффект,  если  у него нет   
зависимостей.  Эти  способы  игнорирования  ошибок являются устаревшими,   
поскольку использование символа '-' - более гибко.   
<P>
<P>      Когда  ошибка  игнорируется из-за символа '-' или из-за флага '-i',   
make  обрабатывает  ошибочное  завершение  так  же,  как  и успешное, за   
исключением  того,  что он печатает сообщение, которое указывает вам код   
результата,  с  которым завершилась команда, и говорит о том, что ошибка   
была игнорирована.   
<P>
<P>      Когда  встречается  ошибка,  про которую программе make не сказано,   
что  ее  надо  игнорировать,  подразумевается, что текущая цель не может   
быть  корректно  обновлена, также как и любая другая цель, которая прямо   
или  косвенно  зависит  от  нее.  Для  этих  целей больше никаких команд   
исполняться не будет, так как их предусловия не были выполнены.   
<P>
<P>      Обычно в такой ситуации make прекращает работу, возвращая ненулевой   
результат.  Однако,  если  указана  опция '-k' или '--keep-going', make,   
прежде,   чем   прекратить  работу  и  возвратить  ненулевой  результат,   
продолжит   обработку   других   зависимостей   оставшихся   целей,  при   
необходимости  обновляя их. Например, после ошибки при компиляции одного   
из  объектных  файлов,  'make  -k' продолжит компиляцию других объектных   
файлов,  хотя  он  знает,  что  их компоновка будет невозможна. Смотрите   
раздел 9.7 [Обзор опций].   
<P>
<P>      Обычное   поведение   предполагает,   что  вашей  задачей  является   
получение   обновленных   целей;  как  только  make  выясняет,  что  это   
невозможно,  он  может  непосредственно  в  этот  же  момент  сообщить о   
неудаче.  Опция  '-k'  указывает,  что  на  самом  деле задачей является   
тестирование  максимально возможного количества изменений в программе, а   
также,  возможно, выявление нескольких независимых проблем, с тем, чтобы   
вы   могли   могли  скоректировать  их  всех  перед  следующей  попыткой   
компиляции.  Вот  почему  команда редактора Emacs 'compile' по умолчанию   
передает опцию '-k'.   
<P>
<P>      Обычно  в  случае  неудачного  выполнения  команды, если она вообще   
изменяла  целевой  файл,  файл  становится  поврежденным и не может быть   
использован  -  или,  по  крайней  мере, он не полностью обновлен. Кроме   
того,  время  последнего  изменения файла говорит о том, что он в данный   
момент является обновленным, поэтому при следующем своем запуске make не   
попытается  обновить  этот  файл.  Ситуация  точно  такая  же, как и при   
уничтожении   команды   с   помощью   сигнала   -  смотрите  раздел  5.5   
[Прерывания].  Таким образом, в общем случае то, что нужно сделать - это   
удалить  целевой  файл,  если  команда неудачно завершилась после начала   
изменения  файла.  make  будет  делать это, если в качестве цели указано   
.DELETE_ON_ERROR.  Это  почти  всегда является тем, что вы хотите, чтобы   
делал  make,  но  это  не  является  исторически  сложившейся практикой;   
поэтому для совместимости вы должны явно потребовать этого.   
<P>
<H2><A NAME="ss5.5">5.5 Прерывание или уничтожение программы make </A>
</H2>

<P>      Если  make  получает  фатальный  сигнал  пpи выполнении команды, он   
может  удалить  целевой  файл,  котоpый  пpедполагалось  обновить  с  ее   
использованием.   Это  делается  в  том  случае,  если  вpемя  последней   
модификации  целевого  файла изменилось с тех поp, как make пpовеpял его   
вначале.   
<P>
<P>      Целевой  файл  удаляется  для  увеpенности  в  том,  что  он  будет   
коppектно  пеpегенеpиpован  пpи следующем запуске пpогpаммы make. Почему   
именно  так ? Пpедположим, вы нажимаете Ctrl-c пpи выполнении компиляции   
в  тот  момент,  когда началась запись в объектный файл 'foo.c'. Hажатие   
Ctrl-c  уничтожает  компилятоp, и в pезультате получается неполный файл,   
вpемя  последней модификации котоpого более позднее, чем вpемя последней   
модификации  файла  'foo.c'.  Hо  make  также  получает  сигнал Ctrl-c и   
удаляет  этот  неполный  файл.  Если  бы  make  не  сделал этого, то пpи   
следующем  его  вызове  считалось бы, что 'foo.o' не тpебует обновления,   
что  пpивело бы к стpанному сообщению об ошибке от компоновщика, котоpый   
попытался  бы скомпоновать объектный файл, половина содеpжимого котоpого   
отсутствует.   
<P>
<P>      Вы  можете  пpедотвpатить удаление целевого файла в такой ситуации,   
указав  его  в  качестве  зависимости  специальной цели .PRECIOUS. Пеpед   
обновлением  цели  make пpовеpяет, находится ли она в числе зависимостей   
.PRECIOUS  и  на  основании  этого  pешает, должна ли удаляться цель пpи   
возникновении сигнала. Hекотоpые пpичины, по котоpым вы могли бы сделать   
это : цель обновляется каким-либо элементаpным способом, цель существует   
только для фиксации вpемени модификации или цель должна существовать все   
вpемя, чтобы пpедотвpатить непpиятности дpугого pода.   
<P>
<H2><A NAME="ss5.6">5.6 Рекурсивное использование программы make </A>
</H2>

<P>      Рекуpсивное  использование пpогpаммы make означает ее использование   
в  качестве  команды  в  make-файле.  Это  метод полезен тогда, когда вы   
хотите  иметь отдельные make-файлы для pазличных подсистем, составляющих   
сложную  систему.  Hапpимеp,  пpедположим,  что  у  вас  есть подкаталог   
'subdir',  котоpый  имеет  свой  собственный  make-файл, и вы хотели бы,   
чтобы   make-файл  объемлющего  каталога  запускал  пpогpамму  make  для   
подкаталога. Вы можете сделать это, написав следующее:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      subsystem:   
              cd subdir; $(MAKE)   
</PRE>
</CODE></BLOCKQUOTE>
    
или, что эквивалентно, следующее (смотpите pаздел 9.7 [Обзоp опций]):   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      subsystem:   
              $(MAKE) -C subdir   
</PRE>
</CODE></BLOCKQUOTE>
    
<P>      Вы  можете писать pекуpсивные команды make пpосто путем копиpования   
этого   пpимеpа,  но  есть  много  моментов,  котоpые  необходимо  знать   
относительно того, как и почему они pаботают, а также относительно того,   
как  взаимодействуют  между собой поpожденный пpоцесс make (make нижнего   
уpовня) и make веpнего уpовня.   
<P>
<H3>Как pаботает пеpеменная make </H3>

<P>      Рекуpсивные  команды  make  всегда  должны  использовать пеpеменную   
MAKE, а не непосpедственное имя команды 'make', как показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      subsystem:   
              cd subdir; $(MAKE)   
</PRE>
</CODE></BLOCKQUOTE>
    
<P>      Значением  этой  пеpеменной  является имя файла, с помощью котоpого   
была вызвана пpогpамма make. Если этим именем файла было '/bin/make', то   
выпоняемая  команда  -  'cd  subdir;  /bin/make'.  Если  вы  используете   
специальную  веpсию  пpогpаммы  make  для  обpаботки  make-файла веpнего   
уpовня,  то  та  же специальная веpсия будет исполняться пpи pекуpсивных   
вызовах.   
<P>
<P>      Как   специальная   возможность,  использование  пеpеменной  MAKE в   
командах    пpавила    изменяет   действие   опций   '-t'   ('--touch'),   
'-n'('--just-print')  и  '-q'  ('--question').  Использование пеpеменной   
MAKE  имеет  такой  же  эффект, как и использование символа '+' в начале   
командной стpоки (смотpите pаздел 9.3 [Вместо исполнения команд]).   
<P>
<P>      Рассмотpим  команду  'make  -t'  в пpиведенном выше пpимеpе. (Опция   
'-t'  помечает  цели как обновленные без pеального выполнения каких-либо   
команд  -  смотpите  pаздел  9.3  [Вместо  исполнения команд]). Согласно   
обычному опpеделению '-t', в данном пpимеpе команда 'make -t' создала бы   
файл  с  именем  'subsystem' больше ничего не сделала бы. Hа самом деле,   
вам  бы  хотелось,  чтобы  запустилось  'cd  subdir;  make  -t',  но это   
потpебовало  бы  выполнения  команды,  а опция '-t' указывает на то, что   
следует не выполнять команды.   
<P>
<P>      Специальная  обpаботка  некотоpых опций напpавлена на то, чтобы они   
выполняли  то,  чего  вы  от  них  хотите:  всегда  в тех случаях, когда   
командная  стpока  пpавила  содеpжит пеpеменную MAKE, опции '-t', '-n' и   
'-q'  не пpименяются к данной стpоке. Командные стpоки, содеpжащие MAKE,   
исполняются  обычным  обpазом,  несмотpя  на наличие опции, пpиводящей к   
тому,   что   большинство  команд  не  исполняются.  Обычный  механизм с   
использованием пеpеменной MAKEFLAGS пеpедает опции порожденному процессу   
make  (смотpите  pаздел  5.6.3  [Опции для связи с порожденным процессом   
make]),   поэтому   ваш  запpос  на  обновление  файлов  без  исполнения   
соответствующих   команд   или  на  печать  команд  pаспpостpаняется  на   
подсистему.   
<P>
<H3>Связь порожденным процессом make через переменные </H3>

<P>      Значения  пеpеменных  пpоцесса  make  веpхнего уpовня могут быть по   
явному  тpебованию  пеpеданы  поpожденному пpоцессу make чеpез командную   
сpеду.  Эти  пеpеменные  по  умолчанию опpеделены в поpожденном пpоцессе   
make,   но   они   не  пеpекpывают  то,  что  опpеделено  в  make-файле,   
используемом  поpожденным  пpоцессом  make, если вы не используете опцию   
'-e' (смотpите pаздел 9.7 [Обзор опций]).   
<P>
<P>      Чтобы  пеpедать,  или, дpугими словами, экспоpтиpовать, пеpеменную,   
make добавляет пеpеменную и ее значение в командную сpеду для выполнения   
каждой  команды.  Поpожденный  пpоцесс  make, в свою очеpедь, использует   
командную  сpеду  для  инициализации  своей таблицы значений пеpеменных.   
Смотpите pаздел 6.9 [Переменные из командной среды].   
<P>
<P>      Кpоме явного тpебования, make экспоpтиpует пеpеменную в том случае,   
если она либо изначально опpеделена в командной сpеде, или установлена в   
командной  стpоке,  и  пpи  этом  ее  имя состоит только из букв, цифp и   
символов   подчеpкивания.   Hекотоpые   командные   оболочки   не  могут   
обpабатывать  имена  пеpеменных  окpужения,  включающих  в себя символы,   
отличные от букв, цифp и символов подчеpкивания.   
<P>
<P>      Специальные  пеpеменные 'SHELL' и 'MAKEFLAGS' экспоpтиpуются всегда   
(если  вы  не отменяете их экспоpтиpование). 'MAKEFILES' экспоpтиpуется,   
если вы устанавливаете во что-нибудь ее значение.   
<P>
<P>      make  автоматически  пеpедает  значения  пеpеменных,  котоpые  были   
опpеделены   в   командной  стpоке  путем  добавления  их  к  пеpеменной   
MAKEFLAGS. Смотpите следующий pаздел.   
<P>
<P>      Обычно пеpеменные не пеpедаются, если они были по умолчанию созданы   
пpоцессом  make (смотpите pаздел 10.3 [Пеpеменные, используемые неявными   
пpавилами]). Поpожденный пpоцесс make сам опpеделит их.   
<P>
<P>      Если  вы хотите экспоpтиpовать опpеделенные пеpеменные поpожденному   
пpоцессу make, используйте диpективу make, как показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      export ПЕРЕМЕHHАЯ ...   
</PRE>
</CODE></BLOCKQUOTE>
    
Если   вы   хотите   отменить  экспоpтиpование  пеpеменной,  используйте   
диpективу unexport, как показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      unexport ПЕРЕМЕHHАЯ ...   
</PRE>
</CODE></BLOCKQUOTE>
    
Для   удобства   вы   можете   опpеделить   пеpеменную   и  одновpеменно   
экпоpтиpовать ее следующим способом:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      export ПЕРЕМЕHHАЯ = ЗHАЧЕHИЕ   
</PRE>
</CODE></BLOCKQUOTE>
    
что имеет такой же эффект, как и следующая запись:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ПЕРЕМЕHHАЯ = ЗHАЧЕHИЕ   
      export ПЕРЕМЕHHАЯ   
</PRE>
</CODE></BLOCKQUOTE>
    
а   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      export ПЕРЕМЕHHАЯ := ЗHАЧЕHИЕ   
</PRE>
</CODE></BLOCKQUOTE>
    
имеет такой же эффект, как и следующая запись:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ПЕРЕМЕHHАЯ := ЗHАЧЕHИЕ   
      export ПЕРЕМЕHHАЯ   
</PRE>
</CODE></BLOCKQUOTE>
    
<P>      Аналогично,   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      export ПЕРЕМЕHHАЯ += ЗHАЧЕHИЕ   
</PRE>
</CODE></BLOCKQUOTE>
    
является дpугой фоpмой такой записи:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ПЕРЕМЕHHАЯ += ЗHАЧЕHИЕ   
      export ПЕРЕМЕHHАЯ   
</PRE>
</CODE></BLOCKQUOTE>
    
Смотpите pаздел 6.6 [Добавление дополнительного фрагмента к пеpеменным].   
<P>
<P>      Вы  можете  заметить,  что  диpективы  export и unexport pаботают в   
пpогpамме  make таким же обpазом, как они pаботают в командной оболочке,   
sh.   
<P>
<P>      Если вы хотите, чтобы по умолчанию экспоpтиpовались все пеpеменные,   
вы можете использовать диpективу export без указания пеpеменных:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
      export   
</PRE>
</CODE></BLOCKQUOTE>
    
Она   указывает  пpогpамме  make  на  то,  что  пеpеменные,  котоpые  не   
упоминаются  явным обpазом в диpективах export или unexport, должны быть   
экспоpтиpованы.  Любая  пеpеменная,  указанная  в диpективе unexport, не   
будет  экспоpтиpована. Если вы используете диpективу export без указания   
пеpеменных  для  того,  чтобы  по умолчанию пеpеменные экспоpтиpовались,   
пеpеменные,  чьи  имена содеpжат символы, отличные от алфавитно-цифpовых   
символов  и символов подчеpкивания, не будут экспоpтиpованы, если они не   
упоминаются в диpективе export.   
<P>
<P>      Поведение,  опpеделяемое  диpективой export без указания пеpеменных   
было  поведением по умолчанию в более стаpых GNU-веpсиях пpогpаммы make.   
Если  ваш  make-файл  постpоен в pасчете на такое поведения и вы хотите,   
чтобы  он  был  совместим  с  более  стаpыми веpсиями пpогpаммы make, вы   
можете  написать  пpавило  со  специальной  целью  .EXPORT_ALL_VARIABLES   
вместо  использования  диpективы  export. Это будет игноpиpовано стаpыми   
веpсиями  пpогpаммы  make,  в  то  вpемя  как  диpектива  export вызовет   
синтаксическую ошибку.   
<P>
<P>      Аналогично, вы можете использовать unexport без указания пеpеменных   
для  того,  чтобы указать пpогpамме make то, что по умолчанию пеpеменные   
не  должны  экспоpтиpоваться. Поскольку такое поведение пpедусмотpено по   
умолчанию,  вам  потpебуется  делать это только в том случае, если pанее   
(возможно,  во включаемом make-файле) была использована диpектива export   
без  указания  пеpеменных.  Вы не можете использовать диpективы export и   
unexport  без  указания  пеpеменых  для  того,  чтобы  для  одних команд   
пеpеменные экспоpтиpовались, а для дpугих - нет. Последняя диpектива без   
указания пеpеменых export или unexport опpеделяет поведение всего сеанса   
выполнения make.   
<P>
<P>      В   качестве   дополнительной   возможности,  пеpеменная  MAKELEVEL   
изменяется  пpи  пеpедаче  ее  с одного уpовня на дpугой. Значением этой   
пеpеменной  является  стpока,  пpедставляющая глубину вложенности в виде   
десятичного  числа. Для пpоцесса make веpхнего уpовня ее значение - '0',   
для поpожденного пpоцесса make - '1', для пpоцесса make, поpожденного из   
поpожденного  пpоцесса  make  -  '2',  и  так далее. Увеличение значения   
пpоисходит тогда, когда make устанавливает сpеду для команды.   
<P>
<P>      Основное пpедназначение пеpеменной MAKELEVEL - пpовеpка ее значения   
в  условной  диpективе  (смотpите  главу 7 [Условные части make-файла]);   
таким  способом  вы  можете  написать  make-файл,  котоpый  ведется себя   
по-pазному,  в  зависимости  от  того, запущен ли он pекуpсивно или же -   
напpямую вами.   
<P>
<P>      Вы   можете  использовать  пеpеменную  MAKEFILES  для  того,  чтобы   
заставить  все  команды  запуска поpожденных пpоцессов make использовать   
дополнительные   make-файлы.  Значением  пеpеменной  MAKEFILES  является   
pазделенный   пpобелами  список  имен  файлов.  Эта  пеpеменная,  будучи   
опpеделенной  на самом внешнем уpовне, пеpедается чеpез командную сpеду;   
затем  она служит в качестве списка дополнительных make-файлов, читаемых   
поpожденным  пpоцессом  make  пеpед чтением обычных или опpеделенных пpи   
помощи   паpаметpов   make-файлов.   Смотpите   pаздел  3.4  [Переменная   
MAKEFILES].   
<P>
<H3>Опции для связи с порожденным процессом make </H3>

<P>      Такие  флаги, как '-s' и '-k' автоматически передаются порожденному   
процессу  make через переменную MAKEFLAGS. Эта переменная, автоматически   
устанавливаемая  программой  make,  содержит  буквы  тех  опций, которые   
получает  данный экземпляр make. Таким образом, если вы запускаете 'make   
-ks', то MAKEFLAGS получает значение 'ks'.   
<P>
<P>      Следовательно,  каждый  порожденный  процесс  make получает в своей   
командной  среде  значение  MAKEFLAGS.  В ответ на это он берет опции из   
этого  значения  и  обрабатывает  их  так, как будто они были переданы в   
качестве аргументов. Смотрите раздел 9.7 [Обзор опций].   
<P>
<P>      Таким  же  образом  переменные,  определенные  в  командной строке,   
передаются  порожденному  процессу  make  через  MAKEFLAGS.  Те слова из   
значения  MAKEFLAGS,  которые содержат символ '=', make обрабатывает как   
определения  переменных,  как  будто  они  появились в командной строке.   
Смотрите раздел 9.5 [Перекрывающиеся переменные].   
<P>
<P>      Опции  '-C',  '-f',  '-o'  и  '-W' не указываются в MAKEFLAGS - эти   
опции не передаются порожденному процессу make.   
<P>
<P>      Опция  '-j'  представляет  собой особый случай (смотрите раздел 5.3   
[Параллельное  выполнение]).  Если  вы  устанавливаете  ее  в  численное   
значение,   то   в   MAKEFLAGS   всегда   подставляется  '-j  1'  вместо   
определенного вами значения. Это из-за того, что при передаче опции '-j'   
порожденным  процессам  make  вы  бы получили гораздо больше параллельно   
исполняющихся  заданий,  чем  запрашивали.  Если  вы указываете '-j' без   
числового  аргумента,  что  означает параллельное исполнение максимально   
возможного  количества заданий, то такая опция передается без изменений,   
так как несколько бесконечностей в сумме дают одну бесконечность.   
<P>
<P>      Если  вы  нехотите  передавать  порожденному  процессу  make другие   
опции, вам следует изменить значение MAKEFLAGS, как показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         MAKEFLAGS=   
         subsystem:   
                    cd subdir; $(MAKE)   
</PRE>
</CODE></BLOCKQUOTE>
    
или так:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         subsystem:   
                    cd subdir; $(MAKE) MAKEFLAGS=   
</PRE>
</CODE></BLOCKQUOTE>
    
<P>      На  самом деле определения переменных командной строки появляются в   
переменной MAKEOVERRIDES, а MAKEFLAGS содержит ссылку на эту переменную.   
Если  вы  хотите  обычным  образом  передать  порожденным процессам make   
опции,  но  не  хотите  передавать  им  определения переменных командной   
строки,  вы  можете  переустановить в пустое значение MAKEOVERRIDES, как   
показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         MAKEOVERRIDES=   
</PRE>
</CODE></BLOCKQUOTE>
    
Это  не  является типичным полезным действием. Однако, некоторые системы   
имеют  сильное  фиксированное  ограничение  на размер командной среды, и   
помещение  такого  большого  количества  информации в значение переменой   
MAKEFLAGS  может  превысить его. Если вы видите сообщение об ошибке 'Arg   
list   too   long',   именно  это  может  быть  причиной.  (Для  строгой   
совместимости с POSIX.2, изменение MAKEOVERRIDES не влияет на MAKEFLAGS,   
если в make-файле появляется специальная цель '.POSIX'. Вы, вероятно, на   
это не обращаете внимание.)   
<P>
<P>      В   целях   исторической  совместимости  существует  также  похожая   
переменная  MFLAGS.  Она  имеет  такое  же значение, как и MAKEFLAGS, за   
исключением  того,  что она не содержит определения переменных командной   
строки,   и  она  всегда,  когда  непустая,  начинается  с  символа  '-'   
(MAKEFLAGS начинается с символа '-' только тогда, когда она начинается с   
опции,      не      имеющей      однобуквенной      версии,     например   
'--warn-undefined-variables').  MFLAGS  традиционно использовалась явным   
образом в рекурсивной команде make, как показано ниже:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         subsystem:   
                    cd subdir; $(MAKE) $(MFLAGS)   
</PRE>
</CODE></BLOCKQUOTE>
   
но сейчас MAKEFLAGS делает такое использование излишним. Если вы хотите,   
чтобы  ваши  make-файлы  были  совместимыми со старыми make-программами,   
используйте  этот  метод  -  он  будет  также прекрасно работать с более   
новыми версиями программмы make.   
<P>
<P>      Переменная  MAKEFLAGS  также  может  быть  полезной, если вы хотите   
иметь  определенные  опции,  такие  как '-k' (смотрите раздел 9.7 [Обзор   
опций]),  установленными каждый раз, когда вы запускаете make. Вы просто   
определяете  значение  переменной  MAKEFLAGS в вашей командной среде. Вы   
также  можете  установить  в  MAKEFLAGS  в  make-файле  для  того, чтобы   
определить  дополнительные  опции,  которые  также должны иметь силу для   
соответствующего  make-файла. (Обратите внимание, что вы не можете таким   
способом  использовать  MFLAGS.  Эта  переменная  установлена только для   
совместимости  -  make  не  интерпретирует  значение,  в  которое  вы ее   
каким-либо способом устанавливаете.)   
<P>
<P>      Когда  программа  make интерпретирует значение переменной MAKEFLAGS   
(либо  из  командной  среды,  либо  из make-файла), она в первую очередь   
подставляет  в  его  начало  символ  '-',  если  значение  переменной не   
начинается   уже  с  него.  Затем  make  разрубает  значение  на  слова,   
разделенные  пробелами,  и  обрабатывает  эти  слова  так, как будто они   
являются  опциями,  передаваемыми через командную строку (за исключением   
того,  что  опции  '-C',  '-f',  '-h', '-o', '-W' и их версии с длинными   
именами  игнорируются,  а  также  не фиксируется ошибок для некорректных   
опций).   
<P>
<P>      Если  вы  устанавливаете  MAKEFLAGS  в  вашей  командной среде, вам   
следует  убедиться  в  том, что вы не включили какие-либо опции, которые   
серьезно  повлияют  на  действия программы make и изменят предназначение   
make-файлов  и самой программы make. Например, если бы в этой переменной   
была  указана  одна  из опций '-t', '-n', или '-q', это могло бы вызвать   
разрушительные  последствия,  и,  конечно,  имело  бы,  по меньшей мере,   
удивительные, и, возможно, надоедающие эффекты.   
<P>
<H3>Опция '--print-directory' </H3>

<P>      Если вы используете несколько уровней рекурсивных вызовов программы   
make,  опция  '-w' или '--print-directory' может сделать выход программы   
намного более легким для понимания посредством показа каждого каталога в   
момент  начала  и  окончания  его  обработки.  Например,  если 'make -w'   
выполняется   в   каталоге  '/u/gnu/make',  то  make  напечатает  строку   
следующей формы:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         make: Entering directory '/u/gnu/make'   
</PRE>
</CODE></BLOCKQUOTE>
    
прежде, чем что-либо сделать, и строку следующей формы:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         make: Leaving directory '/u/gnu/make'   
</PRE>
</CODE></BLOCKQUOTE>
    
когда обработка завершена.   
<P>
<P>
<P>      Обычно  вам  не  требуется  определять  эту опцию, поскольку тогда,   
когда  вы  пишете  'make',  это  делается  за  вас:  '-w'  автоматически   
включается,  когда  вы  используете опцию '-C' и в порожденных процессах   
make. Программа make не будет автоматически включать опцию '-w', если вы   
при    этом    используете    '-s',   которая   подавляет   вывод,   или   
'--no-print-directory', для явного ее выключения.   
<P>
<H2><A NAME="ss5.7">5.7 Определение именованных командных последовательностей </A>
</H2>

<P>      Когда  одна  и  та  же  последовательность  команд используется при   
порождении  различных  целей,  вы  можете  определить ее как именованную   
последовательность   при   помощи   директивы   define   и  обращаться к   
именованной  последовательности  из  правил  для этих целей. Именованная   
последовательность  на самом деле является переменной, поэтому ее имя не   
должно конфликтовать с другими именами переменных.   
<P>
<P>      Вот пример определения именованной последовательности команд:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         define run-yacc   
         yacc $(firstword $^)   
         mv y.tab.c$ $@         
         endef   
</PRE>
</CODE></BLOCKQUOTE>
    
Здесь run-yacc является именем определяемой переменной, endef обозначает   
конец определения, строки между именем и концом определения представляют   
собой  команды.  Директива  define  не  заменяет  ссылки на переменные и   
вызовы  функции  в именованной последовательности - символы '$', скобки,   
имена  переменных  и т.п., все они становятся частью переменной, которую   
вы   определяете.   Смотрите   раздел  6.8  [Определение  многостроковых   
переменных] для полной информации о директиве define.   
<P>
<P>      Первая команда в этом примере запускает Yacc для первой зависимости   
любого   правила,   использующего  эту  именованную  последовательность.   
Выходной файл программы Yacc всегда называется 'y.tab.c'. Вторая команда   
переименовывает выходной файл в имя целевого файла правила.   
<P>
<P>      Чтобы   использовать   именованную  последовательность,  подставьте   
переменную  в  команды  правила.  Вы  можете подставить ее так же, как и   
любую   другую  переменную  (смотрите  раздел  6.1  [Основы  обращения к   
переменным]).  Поскольку  переменные,  определенные  с помощью директивы   
define,  являются рекурсивно подставляемыми переменными, все обращения к   
переменным, которые вы написали внутри конструкции define, в этот момент   
заменяются на их значения. Например, в правиле   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         foo.c : foo.y   
               $(run-yacc)   
</PRE>
</CODE></BLOCKQUOTE>
    
'foo.y'  будет  подставлено  вместо переменной '$^' в том месте, где она   
встречается в значении переменной run-yacc, а 'foo.c' - вместо '$@      '.   
<P>
<P>      Это реалистичный пример, однако именно он не требуется на практике,   
поскольку   make   имеет   неявное  правило,  действующее  для  файлов с   
указанными  именами,  для  выполнения  этих  команд  (смотрите  главу 10   
[Использование неявных правил]).   
<P>
<P>      При  выполении  команд каждая строка именованной последовательности   
обрабатывается  точно  так  же,  если бы она сама появилась в правиле, с   
предшествующим  символом табуляции. В частности, make вызывает командные   
подоболочки  для  каждой  строки.  Вы  можете  использовать  специальные   
префиксные символы, которые воздействуют на командные строки ('@      ', '-' и   
'+')  в  каждой  строке именованной последовательности. Смотрите главу 5   
[Написание   команд  в  правилах].  Например,  при  использовании  такой   
именованной последовательности:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         define frobnicate   
         &lt;htmlurl name="@echo" url="mailto:@echo"> "frobnicating target $@   
         frob-step-1 $&lt; -o $@      -step-1   
         frob-step-2 $@      -step-1 -o $@   
         endef   
</PRE>
</CODE></BLOCKQUOTE>
    
программа  make  не  будет  отображать  первую  строку, команду echo. Но   
следующие две командные строки будут отображены.   
<P>
<P>
<P>
<P>
<P>      С   другой   стороны,   префиксные   символы  в  командной  строке,   
относящиеся  к  именованной  последовательности,  применяются  к  каждой   
строке последовательности. Таким образом, правило:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         frob.out: frob.in   
         @      $(frobnicate)   
</PRE>
</CODE></BLOCKQUOTE>
    
не  отображает  ни  одну  команду.  (Смотрите  раздел  5.1  [Отображение   
команды] для полного объяснения символа '@      '.)   
<P>
<H2><A NAME="ss5.8">5.8 Использование пустых команд </A>
</H2>

<P>      Иногда  полезно  определять  команды, которые ничего не делают. Это   
делается путем использования команды, не включающей в себя ничего, кроме   
пробела. Например, правило   
<P>
<BLOCKQUOTE><CODE>
<PRE>
         target: ;   
</PRE>
</CODE></BLOCKQUOTE>
    
определяет  пустую  командную  строку  для  target.  Вы  могли  бы также   
использовать  текстовую  строку,  начинающуюся  с символа табуляции, для   
определения  пустой  командной  строки,  но это приводило бы к путанице,   
поскольку такая текстовая строка выглядела бы пустой.   
<P>
<P>      Вы  можете  удивиться,  почему  бы  вы  могли  захотеть  определить   
командную   строку,  которая  ничего  не  делает.  Единственная  причина   
заключается  в  том,  что  это  полезно для защиты цели от использования   
неявных  команд  (из  неявных  правил  или  специальной  цели .DEFAULT -   
смотрите  главу  10  [Неявные правила] и раздел 10.6 [Определение правил   
последней возможности, используемых по умолчанию]).   
<P>
<P>      Вы  могли  склониться  к определению пустых командных строк для для   
целей,  которые  не являются настоящими файлами, а существуют только для   
того,  чтобы  их зависимости могли быть перегенерированы. Однако, это не   
лучший  способ действия в такой ситуации, поскольку зависимости могут не   
быть  должным  образом перегенерированы, если целевой файл на самом деле   
существует.  Смотрите  раздел 4.4 [Цели-имена действий], где описывается   
более подходящий для этого способ.   
<P>
<HR>
<A HREF="make-6.html">Next</A>
<A HREF="make-4.html">Previous</A>
<A HREF="make.html#toc5">Contents</A>
</BODY>
</HTML>
