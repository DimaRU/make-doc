<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
<META HTTP-EQUIV="LAST-MODIFIED" CONTENT="Tue Jan 22 15:04:56 2002 GMT">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="Public">
<META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 
<TITLE> Программа управления компиляцией GNU make 3.73 : Несовместимость и недостающие возможности </TITLE>
<META NAME="DESCRIPTION" CONTENT="Next Previous Contents 13. Несовместимость и недостающие возможности Программы make на различных других системах поддерживают некоторые возможности, которые не реализованы">
<META NAME="RESOURCE-TYPE" CONTENT="Document">
<META NAME="DISTRIBUTION" CONTENT="global">
<META NAME="ROBOTS" CONTENT="ALL">
<META NAME="CHANGED" CONTENT="20020122;15045600">
<META NAME="CHANGEDBY" CONTENT="Valentyn Solomko">
 <LINK HREF="make-14.html" REL=next>
 <LINK HREF="make-12.html" REL=previous>
 <LINK HREF="make.html#toc13" REL=contents>
</HEAD>
<BODY>
<A HREF="make-14.html">Next</A>
<A HREF="make-12.html">Previous</A>
<A HREF="make.html#toc13">Contents</A>
<HR>
<H2><A NAME="s13">13. Несовместимость и недостающие возможности </A></H2>

<P>      Программы  make на различных других системах поддерживают некоторые   
возможности,   которые  не  реализованы  в  GNU-версии  программы  make.   
Стандарт  POSIX.2  (стандарт  IEEE  1003.2-1992),  который специфицирует   
программу make, не требует ни одной из этих возможностей.   
<UL>
<LI>       Цель в форме 'ФАЙЛ((ВХОЖДЕНИЕ))' означает элемент архивного файла   
с  именем  ФАЙЛ.  Элемент  выбирается  не  по  имени,  а по тому,   
является  ли  он  объектным  файлом,  который  определяет  символ   
компоновщика с именем ВХОЖДЕНИЕ.   
    
<P>        Эта  особенность  не была утановлена в GNU-версию программы make,   
из-за  того,  что добавление в программу make знаний о внутреннем   
формате  таблицы  символов  архивного файла противоречит принципу   
модульности.   Смотрите   раздел  11.2.1  [Обновление  символьных   
каталогов архивов].   
<P>
</LI>
<LI>       Суффиксы    (используемые   в   суффиксных   правилах),   которые   
заканчиваются символом '~' имеют специальное значение в программе   
make  для  системы System V - они ссылаются на SCCS-файл, который   
соответствует  файлу, который получился бы, если бы убрали символ   
'~'.  Например, суффиксное правило '.c~.o' породило бы файл 'n.o'   
из   SCCS-файла   's.n.c'.  Для  полноты  охвата  всех  требуемых   
случаев,  требуется  целый  ряд таких суффиксных правил. Смотрите   
раздел 10.7 "Устаревшие суффиксные правила".   
    
<P>        В   GNU-версии  программы  make,  вся  эта  совокупность  случаев   
обрабатывается двумя шаблонными правилами для извлечения файла из   
SCCS,  в  комбинации  с  общей  возможностью  построения  цепочки   
правил. Смотрите раздел 10.4 [Цепочки неявных правил].   
<P>
</LI>
<LI>       В программе make для системы System V строка '$$@      ' имеет странный   
смысл, а именно, в зависимостях правила с несколькими целями, она   
означает конкретную цель, которая обрабатывается.   
    
<P>        Такая  возможность  не предусмотрена в GNU-версии программы make,   
поскольку '$$' всегда означает просто '$'.   
<P>
<P>        Такая  функциональность  может  быть получена через использование   
статических  шаблонных  правил (смотрите раздел 4.10 [Статические   
шаблонные  правила].  Такое правило для программы make из системы   
System V:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
           $(targets): $$&lt;htmlurl name="@.o" url="mailto:@.o"> lib.a   
</PRE>
</CODE></BLOCKQUOTE>
    
может   быть   заменено  на  статическое  шаблонное  правило  для   
GNU-версии программы make:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
           $(targets): %: %.o lib.a   
</PRE>
</CODE></BLOCKQUOTE>
    
</LI>
<LI>       В  программе  make  для  систем System V и 4.3 BSD, имена файлов,   
найденных  при  помощи поиска с использованием переменной VPATH (   
смотрите раздел 4.3 "Поиск зависимостей по каталогам") изменяются   
внутри  командных  строк.  Нам  кажется,  что  намного более ясно   
является  использование во всех случаях автоматических переменных   
и, в результате, эта возможность становится устаревшей.   
    </LI>
<LI>       В  программах  make  для  некоторых  Unix-систем,  автоматическая   
переменная  $*,  появляющаяся  среди  зависимостей правила, имеет   
удивительно  странную  "особенность",  заключающуюся  подстановке   
полного  имени  цели  этого правила. Мы не можем представить, что   
пришло  в головы разработчикам программ make для тех Unix-систем,   
заставив их сделать это; такая особенность полностью противоречит   
с обычнымим определением переменной $*.   
    </LI>
<LI>       В  программах  make  для  некоторых  Unix-систем,  поиск  неяного   
правила  (смотрите  главу  10  "Использование  неявных  правил"),   
по-видимому,  делается  для  всех  целей, а не только тех, что не   
имеют команд. Это означает Вы можете написать так:   
    
<BLOCKQUOTE><CODE>
<PRE>
           foo.o:   
                   cc -c foo.c   
</PRE>
</CODE></BLOCKQUOTE>
    
и программы make для тех Unix-систем догадаются, что файл 'foo.o'   
зависит от файла 'foo.c'.   
    
<P>        Нам   кажется,   что  такую  конструкцию  не  используют.  Состав   
зависимостей  в  программе  make  легко  определяется (по крайней   
мере, в GNU-версии программы make), и работа с такой конструкцией   
просто не укладывается в общую схему.   
<P>
</LI>
<LI>       GNU-версия  программы make не включает никаких встроенных неявных   
правил для и обработки препроцессором программ на языке EFL. Если   
мы  услышим  о ком-нибудь, кто использует использует язык EFL, мы   
охотно добавим эти правила.   
   </LI>
<LI>       Оказывается,  что  в  программе  make для системы SVR4 суффиксное   
правило  может  быть  определено без команд, и оно обрабатывается   
точно  так  же,  как если бы к него были пустые команды (смотрите   
раздел 5.8 "Пустые команды"). Например, такое правило:   
    
<BLOCKQUOTE><CODE>
<PRE>
           .c.a:   
</PRE>
</CODE></BLOCKQUOTE>
    
перекрывает встроенное суффиксное правило '.c.a'.   
    
<P>        Нам кажется, что для правил без команд более ясным было бы просто   
добавлять   всегда   символ   ';'  в  список  зависимостей  цели.   
Вышеприведенный  пример  может легко быть переписан для получения   
требуемого поведения GNU-версии программы make:   
<P>
<BLOCKQUOTE><CODE>
<PRE>
           .c.a: ;   
</PRE>
</CODE></BLOCKQUOTE>
    
</LI>
<LI>       Некоторые  версии  программы  make  вызывают командную оболочку с   
опцией  '-e',  за  исключением  работы  с действующей опцией '-k'   
(смотрите  раздел 9.6 "Проверка компиляции программ"). Опция '-e'   
указывает командной оболочке заканчивать работу, как только любая   
запущенная  ею  программа  возвращает  ненулевой  результат.  Нам   
кажется,  что  было бы более ясным писать каждую командную строку   
командной  оболочки  так,  чтобы  она стояла на своей собственной   
строке в make-файле и не требовать этой специальной обработки.   </LI>
</UL>
    
<P>
<P>
<HR>
<A HREF="make-14.html">Next</A>
<A HREF="make-12.html">Previous</A>
<A HREF="make.html#toc13">Contents</A>
</BODY>
</HTML>
